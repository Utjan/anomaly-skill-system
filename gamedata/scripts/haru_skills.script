-- every param in this table NEEDS to be defined
skills_levels = {
    ["endurance"]   =   { current_level = 0, experience = 0, max_level = 15, prev_requirement = 0, requirement = 750, base_requirement = 750, functor = "haru_skills.level_up_endurance"},
    ["strength"]    =   { current_level = 0, experience = 0, max_level = 15, prev_requirement = 0, requirement = 750, base_requirement = 750, functor = "haru_skills.level_up_strength"},
    ["survival"]    =   { current_level = 0, experience = 0, max_level = 15, prev_requirement = 0, requirement = 750, base_requirement = 750, functor = "haru_skills.level_up_survival"},
    ["scavenging"]  =   { current_level = 0, experience = 0, max_level = 15, prev_requirement = 0, requirement = 750, base_requirement = 750, functor = "haru_skills.level_up_scavenging"}
}
-- params in this table are optional and are up to a modder
skills_stats = {
    ["endurance"]   =   { speed_modifier = 0.75, power_loss = 0.6 , functor = "haru_skills.update_endurance"},
    ["strength"]    =   { weight_modifier = 0.5, base_weight = 0, melee_damage = 0.85 , functor = "haru_skills.update_strength"},
    ["survival"]    =   { resistance = 1.25, bleed_restore = 0, functor = "haru_skills.update_survival" },
    ["scavenging"]  =   { scavenging_skill = -5 }
}

-- I guess this is not the best way to handle things, but I don't wanna overthink this
function level_up_endurance()
    local level = skills_levels.endurance.current_level
    set_stat("endurance", "speed_modifier", 0.75 + (0.025 * level))
    set_stat("endurance", "power_loss", 0.6 + (-0.025 * level))
end

function level_up_strength()
    local level = skills_levels.strength.current_level
    set_stat("strength", "weight_modifier", 0.5 + (0.065 * level))
    set_stat("strength", "melee_damage", 0.85 + (0.025 * level))
	set_stat("strength", "base_weight", 0.5 * level)
end

function level_up_survival()
    local level = skills_levels.survival.current_level
    set_stat("survival", "resistance", 1.25 + (- 0.035 * level))
    set_stat("survival", "bleed_restore", 0.00005 * level)
end

function level_up_scavenging()
    local level = skills_levels.scavenging.current_level
    set_stat("scavenging", "scavenging_skill", 1.35 * level)
end

local death_ini = nil
local math_random = math.random
local sf = string.format
local always_keep_item = {}
local gt = game.translate_string
local parse_keys = utils_data.parse_string_keys
options = {}

function get_max_weight_coef()
    local actor = db.actor
    local tot_weight = actor:get_total_weight()
    local max_weight = actor:get_actor_max_weight()
    local outfit = actor:item_in_slot(7)
    local backpack = actor:item_in_slot(13)
    max_weight = max_weight + (outfit and outfit:get_additional_max_weight() or 0)
    max_weight = max_weight + (backpack and backpack:get_additional_max_weight() or 0)

    actor:iterate_belt(function(owner, obj)
        local c_arty = obj:cast_Artefact()
        max_weight = max_weight + (c_arty and c_arty:AdditionalInventoryWeight() or 0)
    end)

    actor:cast_Actor():conditions():BoosterForEach(function(booster_type, booster_time, booster_value)
        --eBoostMaxWeight
        if (booster_type == 4) then
            max_weight = max_weight + booster_value
        end
    end)
    return tot_weight / max_weight
end

function actor_on_jump()
    local coef = get_max_weight_coef()
    increase_skill("endurance",  clamp((1 - coef) * 10, 0, 999))
    increase_skill("strength", clamp(coef * 10, 0, 999))
end

function actor_on_footstep()
    local coef = get_max_weight_coef()
    increase_skill("endurance",  clamp((1 - coef) * 0.5, 0, 999))
    increase_skill("strength", clamp(0.5 * coef, 0, 999))
end

function creature_on_before_hit(npc, shit, bone_id, flags)
    if not (shit.draftsman and shit.draftsman:id() == 0) then
		return 
	end
    local wpn = db.actor:active_item()
    if not wpn then return end
    if IsWeapon(wpn) and (IsItem("fake_ammo_wpn",wpn:section())) then
        increase_skill("strength", shit.power * 30)
        shit.power = shit.power * skills_stats["strength"].melee_damage
    end
end

function actor_on_before_hit(shit)
    if shit.power < 0 or shit.type == 3 then return end
    increase_skill("survival", shit.power * 30)
    local survival_resistance = skills_stats["survival"].resistance
	shit.power = shit.power * survival_resistance
end

function update_endurance()
    local pwb = skills_stats["endurance"].power_loss
    exec_console_cmd("power_loss_bias " .. tostring(pwb))
    
    local speed_modifier = skills_stats["endurance"].speed_modifier
    speed.add_speed("haruka_endurance_modifier_walk", speed_modifier, false, true)
    speed.add_speed("haruka_endurance_modifier_sprint", speed_modifier, true, true)
end

function update_strength()
    local skill_weight = skills_stats["strength"].weight_modifier
	local skill_weight_base = skills_stats["strength"].base_weight
    weight.add_weight("haruka_strength_modifier_base", skill_weight_base, true)
    weight.multiply_weight("haruka_strength_modifier_mul", skill_weight, true)
end

function update_survival()
    db.actor.bleeding = clamp(db.actor.bleeding - skills_stats["survival"].bleed_restore, 0, 1)
end

local rank_table = {
	["novice"]       = 5,
    ["trainee"]      = 6,
    ["experienced"]  = 7,
    ["professional"] = 8,
    ["veteran"]      = 9,
    ["expert"]       = 10,
    ["master"]       = 15,
    ["legend"]       = 20
}

function npc_on_death_callback(victim, who)
    if who and who:id() ~= 0 then return end
    local rank = ranks.get_obj_rank_name(victim)
    if rank and rank_table[rank] then
        increase_skill("scavenging", rank_table[rank])
    end
end

SpawnCosmetics = death_manager.spawn_cosmetics

function death_manager.spawn_cosmetics(npc, npc_id, npc_comm, npc_rank, visual, rand_condition)
    SpawnCosmetics(npc, npc_id, npc_comm, npc_rank, visual, rand_condition)
    CreateTimeEvent("haruka_scavenger", "haruka_scavanger", 0.1, scavanger_effect, npc)
end

function scavanger_effect(npc)
    local scavenging_skill = skills_stats["scavenging"].scavenging_skill
    local itr = scavenging_skill > 0 and function(npc, item)
        if not item and item:section() then 
            return 
        end
        local sec = item:section()
        if scavenging_skill > math_random(100) and not always_keep_item[sec] then
            alife_create_item(sec, npc)
        end
    end 
    or function(npc, item)
        if not item and item:section() then 
            return 
        end
        local sec = item:section()
        if -scavenging_skill > math_random(100) and not always_keep_item[sec] then
            alife_release(item)
        end
    end 
    npc:iterate_inventory(itr, npc)
	return true
end

function increase_skill(skill, amount)
	local key = "exp_multiplier_" .. skill
    skills_levels[skill].experience = skills_levels[skill].experience + (amount  * options[key])
end

function set_stat(skill, stat, amount)
    skills_stats[skill][stat] = amount
end

local colors = {
    ["clr_green"] = "%" .. "%c[255,178,236,93]",
    ["clr_cyan"] = "%" .. "%c[255,119,181,254]",
    ["clr_red"] = "%" .. "%c[255,175,43,30]",
    ["clr_yellow"] = "%" .. "%c[255,250,218,94]",
    ["clr_white"] = "%" .. "%c[255,220,220,220]",
    ["clr_purple"] = "%" .. "%c[255,138,43,226]"
}

function level_up_skill(name)
    skills_levels[name].current_level = skills_levels[name].current_level + 1 
    local skill = skills_levels[name]
    local req = skill.requirement
    skills_levels[name].prev_requirement = req
    local base = skill.base_requirement
    local level = skill.current_level
    skills_levels[name].requirement = req + (base + (base * (level * 0.25)))
    exec(skill.functor)
    local msg = parse_keys(gt("st_new_level_" .. name) , colors)
    local header = parse_keys(gt("st_new_level_header"), {
        ["name"] = gt("st_player_skills_" .. name),
        ["level"] = level
    })
    db.actor:give_game_news(header, msg, "ui_skills_icon_" .. name, 0, 10000)
    xr_sound.set_sound_play(AC_ID, "pda_tips")
end

local updated = 0
local interval = 1000

function update_stats()
    if time_global() < updated then return end
    updated = time_global() + interval
    for skill, stats in pairs(skills_stats) do
        if stats.functor then
            exec(stats.functor)
        end
    end
    for skill, stats in pairs(skills_levels) do
        if (stats.experience > stats.requirement) and (stats.current_level ~= stats.max_level) then
            level_up_skill(skill)
        end
    end
end

function exec(str)
    if str then
		str = str_explode(str,"%.")
		if str[1] and str[2] and _G[ str[1] ] and _G[ str[1] ][ str[2] ] then
			_G[ str[1] ][ str[2] ]()
		else
			print_dbg("Could not exec function %s", str)
		end
	end
end

function save_state(m_data)
    m_data.skills_levels = skills_levels
    m_data.skills_stats  = skills_stats
end

function load_state(m_data)
    if m_data.skills_levels then
        skills_levels = m_data.skills_levels
    end
    if m_data.skills_stats then
        skills_levels = m_data.skills_levels
    end
    -- update stats, in case new stat was added or something is wrong
    for skill, stats in pairs(skills_levels) do
        exec(stats.functor)
    end
end
local get_config = haru_skills_mcm.get_config

function on_option_change()
    options["exp_multiplier_strength"] = get_config("exp_multiplier_strength")
    options["exp_multiplier_endurance"] = get_config("exp_multiplier_endurance")
    options["exp_multiplier_scavenging"] = get_config("exp_multiplier_scavenging")
    options["exp_multiplier_survival"] = get_config("exp_multiplier_survival")
end

function on_game_start()
    RegisterScriptCallback("actor_on_footstep", actor_on_footstep)
    RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit)
    RegisterScriptCallback("npc_on_before_hit", creature_on_before_hit)
    RegisterScriptCallback("monster_on_before_hit", creature_on_before_hit)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_update", update_stats)
    RegisterScriptCallback("npc_on_death_callback", npc_on_death_callback)
    RegisterScriptCallback("on_option_change", on_option_change)
	on_option_change()
    RegisterScriptCallback("on_game_load", function()
        -- same validation as in death manager
        death_ini = itms_manager.ini_death
        local n = death_ini:line_count("keep_items")
        for i=0,n-1 do
            local result, id, value	= death_ini:r_line_ex("keep_items",i,"","")
            if value == "true" then
                always_keep_item[id] = true
            end
        end
    end)
end